//////////////////////////////////////////////////
// text.eel - SDL2 "SFont" implementation
// Copyright 2005, 2009, 2014, 2017 David Olofson
//////////////////////////////////////////////////

module eelium.text;

import SDL, SDL_image, math, system as sys;

export function Open(renderer)[filename]
{
	// Create object
	local no = {
		.renderer	renderer,
		.glyphs		[],
		.spacing	vector [],
		.xoffs		0,
		.yoffs		0,
		procedure PutString(self, s, _x, _y)[dst, maxx]
		{
			local x, local y = (_x, _y) + self.(xoffs, yoffs);
			if not sizeof s
				return;
			if specified dst
				local d = dst;
			else
				d = nil;
			if specified maxx
				local mx = maxx;
			else
				mx = 9999999;
			local startx = x;
			local gs, local ss = self.(glyphs, spacing);
			local lastg = sizeof gs + 33;
			local uch = self.unknownchar;
			local rn = self.renderer;
			local r = Rect [];
			for local c = 0, sizeof s - 1
			{
				local ch = s[c];
				if ch >= lastg
					ch = uch;
				switch ch
				  case '\n'
				  {
					x = startx;
					y += self.height;
				  }
				  case ' '
					x += self.spacew;
				  case '\t'
				  {
					x -= startx;
					x = floor((x + self.tabw) /
							self.tabw) * self.tabw;
					x += startx;
				  }
				  default
				  {
					ch -= 33;
					RenderCopy(rn, gs[ch], nil, x, y);
					x += self.spacing[ch];
				  }
				if x > mx
					break;
			}
		}
		function Width(self, s)[count]
		{
			local w, local mw = 0;
			if specified count
				local nc = count |< sizeof s;
			else
				nc = sizeof s;
			if not nc
				return 0;
			local ss = self.spacing;
			local lastg = sizeof ss + 33;
			local uch = self.unknownchar;
			for local c = 0, nc - 1
			{
				local ch = s[c];
				if ch >= lastg
					ch = uch;
				switch ch
				  case '\n'
				  {
					mw >|= w;
					w = 0;
				  }
				  case ' '
					w += self.spacew;
				  case '\t'
					w = floor((w + self.tabw) /
							self.tabw) * self.tabw;
				  default
				  {
					ch -= 33;
					w += ss[ch];
				  }
			}
			mw >|= w;
			return mw;
		}
		procedure Offset(self, x, y)
		{
			self.(xoffs, yoffs) = x, y;
		}
	};

	// Load and process font
	if specified filename
		local sfont = Load(filename);
	else
		sfont = Load(sys.MODPATH + "/eelium/fonts/microfont_sh.png");
	local x = 0;
	local last_cut = 0;
	local last_mend = 0;
	local c = MapColor(sfont, 255, 0, 255);
	no.height = sfont.h - 1;
	while x < sfont.w
	{
		if GetPixel(sfont, x, 0) == c
		{
			local mstart = x;
			while x < (sfont.w - 1) and
					(GetPixel(sfont, x, 0) == c)
				x += 1;
			local cut = (mstart + x) / 2;
			if last_cut
			{
				local r = Rect [last_cut, 1, cut - last_cut,
						no.height];
				local tx = Texture [renderer, sfont, r];
				tx.blendmode = BLENDMODE_BLEND;
				no.glyphs.+ tx;
				no.spacing.+ mstart - last_mend + 1;
			}
			last_cut = cut;
			last_mend = x;
		}
		x += 1;
	}

	// Determine width of the space glyph
	no.spacew = 0;
	try
		no.spacew = no.glyphs['i' - 33].w * 1.5;
	if not no.spacew
		no.spacew = no.glyphs['I' - 33].w * 1.5;
	if not no.spacew
		no.spacew = no.glyphs['.' - 33].w * 1.5;
	if not no.spacew
		no.spacew = no.glyphs['!' - 33].w * 1.5;

	// Determine substitute for "unknown character"
	if sizeof no.glyphs > ('?' - 33)
		no.unknownchar = '?';
	else
		no.unknownchar = ' ';

	// Since we're dealing mostly with proportional
	// fonts, there's no obvious way to figure out
	// what a sensible tab width is. I chose to make
	// it 6 x height.
	no.tabw = no.height * 6;

	return no;
}
